

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      TransactionBuilder.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.3.0/highlightjs-line-numbers.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/monokai-sublime.css">

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      OIP HDMW
    </h3>

    <h3>Classes</h3><ul><li id="Account-nav"><a href="Account.html">Account</a><ul class='methods'><li data-type="method" id="Account-_handleWebsocketUpdate-nav"><a href="Account.html#_handleWebsocketUpdate">_handleWebsocketUpdate</a></li><li data-type="method" id="Account-_subscribeToAddressWebsocketUpdates-nav"><a href="Account.html#_subscribeToAddressWebsocketUpdates">_subscribeToAddressWebsocketUpdates</a></li><li data-type="method" id="Account-discoverChain-nav"><a href="Account.html#discoverChain">discoverChain</a></li><li data-type="method" id="Account-discoverChains-nav"><a href="Account.html#discoverChains">discoverChains</a></li><li data-type="method" id="Account-getAddress-nav"><a href="Account.html#getAddress">getAddress</a></li><li data-type="method" id="Account-getAddresses-nav"><a href="Account.html#getAddresses">getAddresses</a></li><li data-type="method" id="Account-getBalance-nav"><a href="Account.html#getBalance">getBalance</a></li><li data-type="method" id="Account-getChain-nav"><a href="Account.html#getChain">getChain</a></li><li data-type="method" id="Account-getExtendedPrivateKey-nav"><a href="Account.html#getExtendedPrivateKey">getExtendedPrivateKey</a></li><li data-type="method" id="Account-getExtendedPublicKey-nav"><a href="Account.html#getExtendedPublicKey">getExtendedPublicKey</a></li><li data-type="method" id="Account-getMainAddress-nav"><a href="Account.html#getMainAddress">getMainAddress</a></li><li data-type="method" id="Account-getNextChainAddress-nav"><a href="Account.html#getNextChainAddress">getNextChainAddress</a></li><li data-type="method" id="Account-getNextChangeAddress-nav"><a href="Account.html#getNextChangeAddress">getNextChangeAddress</a></li><li data-type="method" id="Account-getUsedAddresses-nav"><a href="Account.html#getUsedAddresses">getUsedAddresses</a></li><li data-type="method" id="Account-onWebsocketUpdate-nav"><a href="Account.html#onWebsocketUpdate">onWebsocketUpdate</a></li><li data-type="method" id="Account-sendPayment-nav"><a href="Account.html#sendPayment">sendPayment</a></li></ul></li><li id="Address-nav"><a href="Address.html">Address</a><ul class='methods'><li data-type="method" id="Address-_processWebsocketUpdate-nav"><a href="Address.html#_processWebsocketUpdate">_processWebsocketUpdate</a></li><li data-type="method" id="Address-addSpentTransaction-nav"><a href="Address.html#addSpentTransaction">addSpentTransaction</a></li><li data-type="method" id="Address-deserialize-nav"><a href="Address.html#deserialize">deserialize</a></li><li data-type="method" id="Address-getBalance-nav"><a href="Address.html#getBalance">getBalance</a></li><li data-type="method" id="Address-getECPair-nav"><a href="Address.html#getECPair">getECPair</a></li><li data-type="method" id="Address-getPrivateAddress-nav"><a href="Address.html#getPrivateAddress">getPrivateAddress</a></li><li data-type="method" id="Address-getPublicAddress-nav"><a href="Address.html#getPublicAddress">getPublicAddress</a></li><li data-type="method" id="Address-getTotalReceived-nav"><a href="Address.html#getTotalReceived">getTotalReceived</a></li><li data-type="method" id="Address-getTotalSent-nav"><a href="Address.html#getTotalSent">getTotalSent</a></li><li data-type="method" id="Address-getUnconfirmedBalance-nav"><a href="Address.html#getUnconfirmedBalance">getUnconfirmedBalance</a></li><li data-type="method" id="Address-getUnspent-nav"><a href="Address.html#getUnspent">getUnspent</a></li><li data-type="method" id="Address-onWebsocketUpdate-nav"><a href="Address.html#onWebsocketUpdate">onWebsocketUpdate</a></li><li data-type="method" id="Address-removeSpent-nav"><a href="Address.html#removeSpent">removeSpent</a></li><li data-type="method" id="Address-serialize-nav"><a href="Address.html#serialize">serialize</a></li><li data-type="method" id="Address-signMessage-nav"><a href="Address.html#signMessage">signMessage</a></li><li data-type="method" id="Address-updateState-nav"><a href="Address.html#updateState">updateState</a></li><li data-type="method" id="Address-verifySignature-nav"><a href="Address.html#verifySignature">verifySignature</a></li></ul></li><li id="Coin-nav"><a href="Coin.html">Coin</a><ul class='methods'><li data-type="method" id="Coin-_handleWebsocketUpdate-nav"><a href="Coin.html#_handleWebsocketUpdate">_handleWebsocketUpdate</a></li><li data-type="method" id="Coin-_subscribeToAccountWebsocketUpdates-nav"><a href="Coin.html#_subscribeToAccountWebsocketUpdates">_subscribeToAccountWebsocketUpdates</a></li><li data-type="method" id="Coin-addAccount-nav"><a href="Coin.html#addAccount">addAccount</a></li><li data-type="method" id="Coin-discoverAccounts-nav"><a href="Coin.html#discoverAccounts">discoverAccounts</a></li><li data-type="method" id="Coin-getAccount-nav"><a href="Coin.html#getAccount">getAccount</a></li><li data-type="method" id="Coin-getAccounts-nav"><a href="Coin.html#getAccounts">getAccounts</a></li><li data-type="method" id="Coin-getAddress-nav"><a href="Coin.html#getAddress">getAddress</a></li><li data-type="method" id="Coin-getBalance-nav"><a href="Coin.html#getBalance">getBalance</a></li><li data-type="method" id="Coin-getCoinInfo-nav"><a href="Coin.html#getCoinInfo">getCoinInfo</a></li><li data-type="method" id="Coin-getExtendedPrivateKey-nav"><a href="Coin.html#getExtendedPrivateKey">getExtendedPrivateKey</a></li><li data-type="method" id="Coin-getExtendedPublicKey-nav"><a href="Coin.html#getExtendedPublicKey">getExtendedPublicKey</a></li><li data-type="method" id="Coin-getMainAddress-nav"><a href="Coin.html#getMainAddress">getMainAddress</a></li><li data-type="method" id="Coin-onWebsocketUpdate-nav"><a href="Coin.html#onWebsocketUpdate">onWebsocketUpdate</a></li><li data-type="method" id="Coin-sendPayment-nav"><a href="Coin.html#sendPayment">sendPayment</a></li></ul></li><li id="TransactionBuilder-nav"><a href="TransactionBuilder.html">TransactionBuilder</a><ul class='methods'><li data-type="method" id="TransactionBuilder-addFrom-nav"><a href="TransactionBuilder.html#addFrom">addFrom</a></li><li data-type="method" id="TransactionBuilder-addTo-nav"><a href="TransactionBuilder.html#addTo">addTo</a></li><li data-type="method" id="TransactionBuilder-buildInputsAndOutputs-nav"><a href="TransactionBuilder.html#buildInputsAndOutputs">buildInputsAndOutputs</a></li><li data-type="method" id="TransactionBuilder-buildTX-nav"><a href="TransactionBuilder.html#buildTX">buildTX</a></li><li data-type="method" id="TransactionBuilder-discoverChange-nav"><a href="TransactionBuilder.html#discoverChange">discoverChange</a></li><li data-type="method" id="TransactionBuilder-getUnspents-nav"><a href="TransactionBuilder.html#getUnspents">getUnspents</a></li><li data-type="method" id="TransactionBuilder-parseOptions-nav"><a href="TransactionBuilder.html#parseOptions">parseOptions</a></li><li data-type="method" id="TransactionBuilder-sendTX-nav"><a href="TransactionBuilder.html#sendTX">sendTX</a></li></ul></li><li id="Wallet-nav"><a href="Wallet.html">Wallet</a><ul class='methods'><li data-type="method" id="Wallet-_handleWebsocketUpdate-nav"><a href="Wallet.html#_handleWebsocketUpdate">_handleWebsocketUpdate</a></li><li data-type="method" id="Wallet-addCoin-nav"><a href="Wallet.html#addCoin">addCoin</a></li><li data-type="method" id="Wallet-addTestnetCoins-nav"><a href="Wallet.html#addTestnetCoins">addTestnetCoins</a></li><li data-type="method" id="Wallet-fromEntropy-nav"><a href="Wallet.html#fromEntropy">fromEntropy</a></li><li data-type="method" id="Wallet-fromMnemonic-nav"><a href="Wallet.html#fromMnemonic">fromMnemonic</a></li><li data-type="method" id="Wallet-fromSeed-nav"><a href="Wallet.html#fromSeed">fromSeed</a></li><li data-type="method" id="Wallet-getCoin-nav"><a href="Wallet.html#getCoin">getCoin</a></li><li data-type="method" id="Wallet-getCoinBalances-nav"><a href="Wallet.html#getCoinBalances">getCoinBalances</a></li><li data-type="method" id="Wallet-getCoins-nav"><a href="Wallet.html#getCoins">getCoins</a></li><li data-type="method" id="Wallet-getEntropy-nav"><a href="Wallet.html#getEntropy">getEntropy</a></li><li data-type="method" id="Wallet-getExchangeRates-nav"><a href="Wallet.html#getExchangeRates">getExchangeRates</a></li><li data-type="method" id="Wallet-getExplorerUrls-nav"><a href="Wallet.html#getExplorerUrls">getExplorerUrls</a></li><li data-type="method" id="Wallet-getFiatBalances-nav"><a href="Wallet.html#getFiatBalances">getFiatBalances</a></li><li data-type="method" id="Wallet-getMnemonic-nav"><a href="Wallet.html#getMnemonic">getMnemonic</a></li><li data-type="method" id="Wallet-getNetworks-nav"><a href="Wallet.html#getNetworks">getNetworks</a></li><li data-type="method" id="Wallet-getSeed-nav"><a href="Wallet.html#getSeed">getSeed</a></li><li data-type="method" id="Wallet-onWebsocketUpdate-nav"><a href="Wallet.html#onWebsocketUpdate">onWebsocketUpdate</a></li><li data-type="method" id="Wallet-sendPayment-nav"><a href="Wallet.html#sendPayment">sendPayment</a></li><li data-type="method" id="Wallet-setExplorerUrls-nav"><a href="Wallet.html#setExplorerUrls">setExplorerUrls</a></li></ul></li></ul><h3>Modules</h3><ul><li id="util-nav"><a href="module-util.html">util</a><ul class='methods'><li data-type="method" id="util-isEntropy-nav"><a href="module-util.html#~isEntropy">isEntropy</a></li><li data-type="method" id="util-isMnemonic-nav"><a href="module-util.html#~isMnemonic">isMnemonic</a></li><li data-type="method" id="util-isValidPublicAddress-nav"><a href="module-util.html#~isValidPublicAddress">isValidPublicAddress</a></li><li data-type="method" id="util-isValidWIF-nav"><a href="module-util.html#~isValidWIF">isValidWIF</a></li><li data-type="method" id="util-toBase58-nav"><a href="module-util.html#~toBase58">toBase58</a></li></ul></li></ul><h3 id="global-nav"><a href="global.html">Global</a></h3>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        TransactionBuilder.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import bitcoin from 'bitcoinjs-lib'
import bip32 from 'bip32'
import bip32utils from 'bip32-utils'
import coinselect from 'coinselect'

import Address from './Address'
import { sign } from './TransactionBuilderHelpers'
import { isValidPublicAddress } from './util'

/**
 * An Output for a Transaction
 * @typedef {Object} OutputAddress
 * @example
 * { "FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001 }
 * @example
 * { "base58-public-address": valueInWholeCoin }
 */

/**
 * An object returned from `coinselect` that contains information about selected inputs, outputs, and the fee.
 * @typedef {Object} SelectedInputOutput
 * @property {Array&lt;TXInput>} inputs - An Array of Transaction Inputs
 * @property {Array&lt;TXOutput>} outputs - An Array of Transaction Outputs
 * @property {number} fee - The Calculated Fee to pay
 */

/**
 * A Transaction Input
 * @typedef {Object} TXInput
 * @property {string} address - Base58 Public Address
 * @property {string} txId - Parent Transaction ID
 * @property {number} vout - Index of output in Parent Transaction
 * @property {string} scriptPubKey - Script Public Key Hash
 * @property {number} value - Balance of the input in Satoshis
 * @example
 * {
 * 	address: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
 * 	txId: '7687e361f00998f96b29938bf5b7d9003a15ec182c13b6ddbd5adc0f993cbf9c',
 * 	vout: 1,
 * 	scriptPubKey: '76a9141bfcff1731caf3a16225d3e78735ddc229e4fc6c88ac',
 * 	value: 100000
 * }
 */

/**
 * A Transaction Output
 * @typedef {Object} TXOutput
 * @property {string} address - Base58 Public Address
 * @property {number} value - Amount to send Satoshis
 * @example
 * {
 * 	address: 'FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu',
 * 	value: 1000
 * }
 */

/**
 * Build &amp; Send Transactions out to the network Easily using Addresses!
 */
class TransactionBuilder {
  /**
	 * Create a new TransactionBuilder
	 * ##### Example
	 * ```
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
	 * 	floData: "Testing oip-hdmw!"
	 * })
	 * ```
	 * @param  {CoinInfo} coin - CoinInfo for this specific Network you want to send the Transaction on.
	 * @param  {Object} [options]
	 * @param  {Address|Array.&lt;Address>} options.from - The Address(es) to send from.
	 * @param  {OutputAddress|Array.&lt;OutputAddress>} options.to - The amounts &amp; Address(es) to send to.
	 * @param  {string} [options.floData=""] - The FloData to be added to the Transaction
	 * @param  {Account} [account] - An Account to get a Change Address from if needed, if undefined, change will be sent to first `from` Address.
	 * @return {TransactionBuilder}
	 */
  constructor (coin, options, account) {
    this.coin = coin
    this.account = account

    // Addresses we are sending from
    this.from = []
    // Addresses we want to send to &amp; amounts
    this.to = []

    this.passedOptions = {}

    this.parseOptions(options)
  }
  /**
	 * Add an Address to send from
	 * @example
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo)
	 * builder.addFrom(address);
	 * @param {Address} address - Address to add to the From Addresses
	 */
  addFrom (address) {
    if (address instanceof Address) {
      if (isValidPublicAddress(address.getPublicAddress(), this.coin.network)) {
        this.from.push(address)
      }
    } else {
      throw new Error('From Address MUST BE InstanceOf Address')
    }
  }
  /**
	 * Add an Address and Amount to send to
	 * @example
	 * import bip32 from 'bip32'
	 * import { TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var builder = new TransactionBuilder(Networks.flo)
	 * builder.addTo("FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu", 0.001);
	 * @param {string} address - Base58 Public Address to send To
	 * @param {number} amount - Amount to Send (in whole coin)
	 */
  addTo (address, amount) {
    if (isValidPublicAddress(address, this.coin.network) &amp;&amp; !isNaN(amount)) {
      var tmpTo = {
        address: address,
        value: amount
      }
      this.to.push(tmpTo)
    }
  }
  /**
	 * Load From &amp; To addresses
	 * @param  {Object} options
	 * @param  {Address|Array.&lt;Address>} options.from - The Address(es) to send from.
	 * @param  {OutputAddress|Array.&lt;OutputAddress>} options.to - The amounts &amp; Address(es) to send to.
	 * @param  {string} [options.floData=""] - The FloData to be added to the Transaction
	 * @example
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo)
	 *
	 * builder.parseOptions({
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
	 * 	floData: "Testing oip-hdmw!"
	 * })
	 */
  parseOptions (options) {
    if (!options) { return }

    // Grab the From Addresses, it can be an array or regular.
    if (options.from) {
      if (Array.isArray(options.from)) {
        for (var addr of options.from) {
          this.addFrom(addr)
        }
      } else {
        this.addFrom(options.from)
      }
    }

    // Load who we are sending to
    if (options.to) {
      // Check if we are providing an address string and amount seperately
      if (Array.isArray(options.to)) {
        for (var payTo of options.to) {
          for (var address in payTo) {
            this.addTo(address, payTo[address])
          }
        }
      } else {
        for (var address in options.to) {
          this.addTo(address, options.to[address])
        }
      }
    }

    this.passedOptions = options
  }
  /**
	 * Get the Unspent Transaction Outputs for all the From addresses specified.
	 * @example
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
	 * })
	 *
	 * builder.getUnspents().then((utxos) => {
	 * 	console.log(utxos)
	 * })
	 * @return {Promise&lt;Array.&lt;utxo>>} Returns a Promise that will resolve to an Array of unspent utxos
	 */
  async getUnspents () {
    let utxos = []

    for (let addr of this.from) {
      try {
        let tmp_utxos = await addr.getUnspent()

        for (let utxo of tmp_utxos) { utxos.push(utxo) }
      } catch (e) { throw new Error('Unable to get Unspents \n' + e) }
    }

    return utxos
  }
  /**
	 * Get calculated Inputs and Outputs (and Fee) for From and To Addresses
	 * @param {Array.&lt;utxo>} [manual_utxos] - Pass in utxos for the function to use. If not passed, it will call the function getUnspents()
	 * @example
	 * import bip32 from 'bip32'
	 * import { Account, Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
	 * var account = new Account(accountMaster, networks.flo, false);
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
	 * }, account)
	 *
	 * builder.buildInputsAndOutputs().then((calculated) => {
	 * 	console.log(calculated.inputs)
	 * 	console.log(calculated.outputs)
	 * 	console.log(calculated.fee)
	 * })
	 * @return {SelectedInputOutput}
	 */
  async buildInputsAndOutputs (manual_utxos) {
    try {
      await this.discoverChange()
    } catch (e) { throw new Error('Unable to Discover Change Addresses \n' + e) }

    let utxos = manual_utxos

    if (!utxos) {
      try {
        utxos = await this.getUnspents()
      } catch (e) { throw new Error('Unable to get Unspents for Addresses \n' + e) }
    }

    var formattedUtxos = utxos.map((utxo) => {
      return {
        address: utxo.address,
        txId: utxo.txid,
        vout: utxo.vout,
        scriptPubKey: utxo.scriptPubKey,
        value: utxo.satoshis,
        confirmations: utxo.confirmations
      }
    })

    var targets = this.to.map((toObj) => {
      return {
        address: toObj.address,
        value: Math.floor(toObj.value * this.coin.satPerCoin)
      }
    })

    var extraBytesLength = 0
    var extraBytes = this.coin.getExtraBytes(this.passedOptions)

    if (extraBytes) { extraBytesLength = extraBytes.length }

    var utxosNoUnconfirmed = formattedUtxos.filter(utx => utx.confirmations > 0)

    var selected = coinselect(utxosNoUnconfirmed, targets, Math.ceil(this.coin.feePerByte), extraBytesLength)

    // Check if we are able to build inputs/outputs off only unconfirmed transactions with confirmations > 0
    if (selected.inputs &amp;&amp; selected.inputs.length > 0 &amp;&amp; selected.outputs &amp;&amp; selected.outputs.length > 0 &amp;&amp; selected.fee) { return selected } else // else, build with the regular ones
    { return coinselect(formattedUtxos, targets, Math.ceil(this.coin.feePerByte), extraBytesLength) }
  }
  /**
	 * Discover the used change addresses if we were passed an Account to discover from.
	 * @example
	 * import bip32 from 'bip32'
	 * import { Account, Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
	 * var account = new Account(accountMaster, networks.flo, false);
	 *
	 * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
	 * var address = new Address(node, Networks.flo, false)
	 *
	 * var builder = new TransactionBuilder(Networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
	 * }, account)
	 *
	 * builder.discoverChange().then(() => {
	 * 	console.log("Done Discovering Change!")
	 * })
	 * @return {Promise}
	 */
  async discoverChange () {
    if (this.account) {
      try {
        await this.account.discoverChain(1)
        return
      } catch (e) { throw new Error('Unable to Discover Chain \n' + e) }
    } else {

    }
  }
  /**
	 * Build the Transaction hex for the From and To addresses
	 * @param {SelectedInputOutput} [manual_selected] - Inputs and Outputs to use. If not passed, the function buildInputsAndOutputs() is run.
	 * @example
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
	 * var account = new Account(accountMaster, networks.flo, false);
	 *
	 * // F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
	 * var addressNode = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", networks.flo.network)
	 * var address = new Address(addressNode, networks.flo, false);
	 *
	 * var builder = new TransactionBuilder(networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
	 * 	floData: "Testing oip-hdmw!"
	 * }, account)
	 *
	 * builder.buildTX().then((hex) => {
	 * 	console.log(hex)
	 * })
	 * @return {Promise&lt;string>} Returns a Promise that resolves to the calculated Transaction Hex
	 */
  async buildTX (manual_selected) {
    let selected = manual_selected

    if (!selected) {
      try {
        selected = await this.buildInputsAndOutputs()
      } catch (e) {
        throw new Error('Unable to select inputs and outputs \n' + e)
      }
    }

    this.selected = selected

    let inputs = selected.inputs
    let outputs = selected.outputs
    let fee = selected.fee

    // inputs and outputs will be undefined if no solution was found
    if (!inputs || !outputs) {
      throw new Error('No Inputs or Outputs selected! Fail!')
    }

    let txb = new bitcoin.TransactionBuilder(this.coin.network)

    txb.setVersion(this.coin.txVersion)

    inputs.forEach(input => txb.addInput(input.txId, input.vout))

    // Check if we are paying to ourself, if so, merge the outputs to just a single output.
    // Check if we only have one from address, and two outputs (i.e. pay to and change)
    if (this.from.length === 1 &amp;&amp; outputs.length === 2) {
      // If the first input is sending to the from address, and there is a change output,
      // then merge the outputs.
      if (outputs[0].address === this.from[0].getPublicAddress() &amp;&amp; !outputs[1].address) {
        let totalToSend = outputs[0].value + outputs[1].value
        outputs = [{
          address: this.from[0].getPublicAddress(),
          value: totalToSend
        }]
      }
    }

    outputs.forEach(output => {
      // watch out, outputs may have been added that you need to provide
      // an output address/script for
      if (!output.address) {
        // Check if we have access to an account to get the change address from
        if (this.account) {
          output.address = this.account.getNextChangeAddress().getPublicAddress()
        } else {
          // If the change is undefined, send change to the first from address
          output.address = this.from[0].getPublicAddress()
        }
      }

      txb.addOutput(output.address, output.value)
    })

    for (let i in inputs) {
      for (let addr of this.from) {
        if (addr.getPublicAddress() === inputs[i].address) {
          let extraBytes = this.coin.getExtraBytes(this.passedOptions)

          if (extraBytes) {
            sign(txb, extraBytes, parseInt(i), addr.getECPair())
          } else {
            txb.sign(parseInt(i), addr.getECPair())
          }
        }
      }
    }

    let builtHex

    try {
      builtHex = txb.build().toHex()
    } catch (e) {
		    throw new Error('Unable to build Transaction Hex! \n' + e)
    }

    let extraBytes = this.coin.getExtraBytes(this.passedOptions)

    if (extraBytes) { builtHex += extraBytes }

    return builtHex
  }
  /**
	 * Build &amp; Send the Transaction that we have been forming
	 * @param {String} [manual_hex] - The hex you wish to send the tx for. If not used, the hex is grabbed from buildTX().
	 * @example
	 * import bip32 from 'bip32'
	 * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
	 *
	 * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
	 * var account = new Account(accountMaster, networks.flo, false);
	 *
	 * // F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
	 * var addressNode = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", networks.flo.network)
	 * var address = new Address(addressNode, networks.flo, false);
	 *
	 * var builder = new TransactionBuilder(networks.flo, {
	 * 	from: address,
	 * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
	 * 	floData: "Testing oip-hdmw!"
	 * }, account)
	 *
	 * builder.sendTX().then((txid) => {
	 * 	console.log(txid)
	 * })
	 * @return {Promise&lt;string>} Returns a promise that will resolve to the success TXID
	 */
  async sendTX (manual_hex) {
    let hex = manual_hex

    if (!hex) {
      try {
        hex = await this.buildTX()
      } catch (e) { throw new Error('Unable to build Transaction \n' + e) }
    }

    if (hex) {
      console.log('BroadcastHex: ' + hex)

      let response
      try {
        response = await this.coin.explorer.broadcastRawTransaction(hex)
      } catch (e) { throw new Error('Unable to Broadcast Transaction hex! \n' + e) }

      var txid

      // Handle { txid: "txid" }
      if (response &amp;&amp; typeof response.txid === 'string') { txid = response.txid }

      /**
			 * Handle
			 * {
			 *    txid: {
			 *        result: '05d2dd88d69cc32717d315152bfb474b0b1b561ae9a477aae091714c4ab216ac',
			 *        error: null,
			 *        id: 47070
			 *     }
			 * }
			 */
      if (response &amp;&amp; response.txid &amp;&amp; response.txid.result) {
        txid = response.txid.result
      }

      /**
			 * Handle
			 * {
			 *     result: '05d2dd88d69cc32717d315152bfb474b0b1b561ae9a477aae091714c4ab216ac',
			 *     error: null,
			 *     id: 47070
			 * }
			 */
      if (response &amp;&amp; response.result) {
        txid = response.result
      }

      // Add txid to spentTransactions for each spent input
      for (let inp of this.selected.inputs) {
        for (var addr of this.from) {
          if (addr.getPublicAddress() === inp.address) {
            addr.addSpentTransaction(inp.txId)
          }
        }
      }

      return txid
    } else {
      throw new Error('TransactionBuilder.buildTX() did not create any hex!')
    }
  }
}

module.exports = TransactionBuilder
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  
  
</body>
</html>
